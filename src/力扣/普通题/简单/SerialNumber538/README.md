## 538. 把二叉搜索树转换为累加树（简单）

**链接**：https://leetcode-cn.com/problems/convert-bst-to-greater-tree/

### 题目

&emsp;&emsp;给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。

&emsp;&emsp;输入: 原始二叉搜索树:

````
              5
            /   \
           2     13
````
&emsp;&emsp;输出: 转换为累加树:
````
             18
            /   \
          20     13
````

### 解题思路

**方法一：暴力破解**

&emsp;&emsp;使用 dfs 遍历二叉树，将所有的节点添加到集合中。然后对节点按值降序排序，当前节点的值等于上一节点的值加上当前节点的值。（效率非常低）

**方法二：反中序遍历**

&emsp;&emsp;首先我们要了解二叉搜索树的性质：

* 左子树上所有结点的值均小于它的根结点的值

* 右子树上所有结点的值均大于它的根结点的值

&emsp;&emsp;而中序遍历的顺序为：左根右。因为二叉树搜索树的右子树的值恒大于左子树的值，所以我们可以使用反中序遍历（右根左）对树进行变量，在遍历树的过程中当前节点的值等于上一节点的值加上当前节点的值。

**方法三：Morris 遍历（未弄懂）**

&emsp;&emsp;Morris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其反序中序遍历规则总结如下：

1. 如果当前节点的右子节点为空，处理当前节点，并遍历当前节点的左子节点；
    * 如果当前节点的右子节点不为空，找到当前节点右子树的最左节点（该节点为当前节点中序遍历的前驱节点）；

    * 如果最左节点的左指针为空，将最左节点的左指针指向当前节点，遍历当前节点的右子节点；

2. 如果最左节点的左指针不为空，将最左节点的左指针重新置为空（恢复树的原状），处理当前节点，并将当前节点置为其左节点；

3. 重复步骤 1 和步骤 2，直到遍历结束。

### 代码

**方法一：暴力破解**

[代码链接](Solution1.java)

![提交记录](538(1).png)

**方法二：反中序遍历**

[代码链接](Solution2.java)

![提交记录](538(2).png)

**方法三：Morris 遍历**

[代码链接](Solution3.java)

![提交记录](538(3).png)
