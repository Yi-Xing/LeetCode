## 137. 只出现一次的数字 II（中等）

**链接**：https://leetcode-cn.com/problems/single-number-ii/

### 题目

&emsp;&emsp;给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。

&emsp;&emsp;说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

&emsp;&emsp;输入: [2,2,3,2]

&emsp;&emsp;输出: 3

示例 2:

&emsp;&emsp;输入: [0,1,0,1,0,1,99]

&emsp;&emsp;输出: 99

### 解题思路

#### 方法一

&emsp;&emsp;由题意得数组中的元素，只有一个元素出现一次，其他元素均出现了三次。
假如现在有元素[a,a,b,c,a,c,c]，我们可得 (a+b+c)*3-(a+a+a+b+c+c+c)=2b。
所以我们将数组中的数存储到HashSet集合中，然后求和乘3减去数组中的所有数，最后除以2得到出现一次的元素。

**注意：** 求和乘3可能会超出int类型的最大值，最好使用long类型。

#### 方法二

&emsp;&emsp;对数组中的数进行位运算，数的各二进制位的运算规则都相同，因此只需考虑一位即可，
对于所有数字中的某二进制位 1 的个数，存在 3 种状态，即对 3 余数为 0, 1, 2。
* 若输入二进制位 1 ，则状态按照以下顺序转换；0→1→2→0→...
* 若输入二进制位 0 ，则状态不变。

&emsp;&emsp;由于二进制只能表示0和1，所以我们使用两位二进制来保存3个状态。设此两位分别为 two , one ，
则状态转换变为：00→01→10→00→...

&emsp;&emsp;**位运算的特点** 对于任意二进制位 x 有：
* 异或运算：x ^ 0 = x​ ， x ^ 1 = ~x
* 与运算：x & 0 = 0 ， x & 1 = x 

![手稿](137(2.1).png)

&emsp;&emsp; 由图可知：

**one的计算方法：**
````
if two == 0:
  if n == 0:
    one = one
  if n == 1:
    one = ~one
if two == 1:
    one = 0
````
&emsp;&emsp; 使用异或运算进行简化得：
````
if two == 0:
    one = one ^ n
if two == 1:
    one = 0
````
即：`one = one ^ n & ~two`

**two的计算方法：**根据one的计算结果判断two的值
````
if one == 0:
  if n == 0:
    two = two
  if n == 1:
    two = ~two
if one == 1:
    two = 0
````
&emsp;&emsp; 使用异或运算进行简化得：
````
if one == 0:
    two = two ^ n
if one == 1:
    two=0
````
即：`two = two ^ n & ~one`

**返回值**

&emsp;&emsp;以上是对数字的二进制中的一位进行分析，但对于每一位都一样。
遍历完所有数字后，各二进制位都处于 00 和 01 状态。这两个状态 two 恒为 0，所以返回 one 即可。

### 代码

#### 方法一：

[代码链接](Solution1.java)

![提交记录](137(1).png)

#### 方法二：

[代码链接](Solution2.java)

![提交记录](137(2).png)