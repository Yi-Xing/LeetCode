## 71. 简化路径（中等）

**链接**：https://leetcode-cn.com/problems/simplify-path/

### 题目


&emsp;&emsp;以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。

&emsp;&emsp;在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径

&emsp;&emsp;请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。

**示例 1：**

&emsp;&emsp;输入："/home/"

&emsp;&emsp;输出："/home"

&emsp;&emsp;解释：注意，最后一个目录名后面没有斜杠。

**示例 2：**

&emsp;&emsp;输入："/../"

&emsp;&emsp;输出："/"

&emsp;&emsp;解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。

**示例 3：**

&emsp;&emsp;输入："/home//foo/"

&emsp;&emsp;输出："/home/foo"

&emsp;&emsp;解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。

**示例 4：**

&emsp;&emsp;输入："/a/./b/../../c/"

&emsp;&emsp;输出："/c"

**示例 5：**

&emsp;&emsp;输入："/a/../../b/../c//.//"

&emsp;&emsp;输出："/c"

**示例 6：**

&emsp;&emsp;输入："/a//b////c/d//././/.."

&emsp;&emsp;输出："/a/b/c"



### 解题思路

&emsp;&emsp;根据题意可以得出以下结论

* 路径必须以 / 开头，最后一个目录名（如果存在）不能以 / 结尾。
* 两个目录直接必须只有一个  / 。
* 路径中如果只有一个 . 则不做处理。
* 路径中如果有两个 . 则将目录切换到父级目录，当前为根目录则不做处理。

#### 方法一：

&emsp;&emsp;首先对路径按 / 进行切割，切割成String数组，数组中存储有4种字符：
[..],[.],[字母],[] (切割可能切割出空字符串)。
&emsp;&emsp;我们使用StringBuilder存储路径，首先添加斜杠代表根目录，然后对数组进行遍历

* 当字符串为..且当前不为根目录时，就切换到父级目录，即删除StringBuilder的末尾字符直到遇到斜杠为止。
* 当字符串为字母时，则添加到StringBuilder中并添加斜杠。
* 数组遍历完后，如果当前目录不是根路径则删除末尾斜杠。


#### 方法二：

&emsp;&emsp;将路径拆分为字符数组，创建一个指针指向字符数组中的有效字符（默认为-1）。
然后遍历字符数组，判断每一个字符。

* 当字符不为 / 或指针为-1时；将指针向后移动，并将当前字符赋给指针指向的字符。
* 当字符为 / 时且指针指向的字符为 / ；则无需处理。
* 当字符为 / 时且指针指向的字符为 . 且指针的前一个字符为 /；则将指针向前移动，即不在指向 . 指向 / 。
* 当字符为 / 时且指针指向的字符为 . 且指针的前一个字符为 . 且指针的前前一个字符为 /；则将指针向前回退，直到遇到 / 或到了根目录为止。
* 当字符为 / 时且指针指向的字符为字母；则将指针向后移动，并将当前字符赋给指针指向的字符。
* 数组遍历完后，如果当前目录不是根路径则删除末尾斜杠。返回[0,指针]的字符串。

**注意：**由于此方法是判断字符为斜杠后，然后再对指针指向的字符进行操作，而测试数据的路径末尾可能没有 / ，所以开始之前先向路径末尾添加斜杠。

### 代码

#### 方法一：

[代码链接](Solution1.java)

![提交记录](71(1).png)

#### 方法二：

[代码链接](Solution2.java)

![提交记录](71(2).png)
